### - Use Microsoft Visual Studio programming environment.  //ä½¿ç”¨ Microsoft Visual Studio ç¼–ç ç¯å¢ƒ
#### 1.Windows taskbar, type **Visual Studio**  //è¾“å…¥Visual Studio
<img width="800" alt="Screen Shot 2022-11-29 at 21 43 46" src="https://user-images.githubusercontent.com/31954987/204544892-9a095f07-f43f-45ea-b05c-8b1a1d806bda.png">

#### 2.Select Visual C#
<img width="800" alt="Screen Shot 2022-11-29 at 21 48 19" src="https://user-images.githubusercontent.com/31954987/204545922-c8d4ef59-835d-4591-8402-46bcfdcdab3d.png">


#### - **Solution 'TestHello'** //è§£å†³æ–¹æ¡ˆ 
###### is the top - level solution file. Each application contains a single solution file. A solution can contain one or more project   //åº”ç”¨åŒ…å«ä¸€ä¸ª å•ä¸€çš„ solution ğŸ“ƒï¼Œä¸€ä¸ª solution åŒ…å« ä¸€ä¸ªæˆ–å¤šä¸ª project 

#### - **TestHello** C# project file. //C# é¡¹ç›®æ–‡ä»¶
 
###### Each project file references one or more file containing the source code and other artifacts for the project, such as graphics images. // æ¯ä¸ªé¡¹ç›®æ–‡ä»¶å‚è€ƒ ä¸€ä¸ª æˆ–è€… å¤šä¸ªæ–‡ä»¶ ä¸”åŒ…å«æºä»£ç  ä¸å…¶ä»– äººå·¥åˆ¶å“ ä¾‹å¦‚ å›¾åƒ
###### You must write all the source code in a single project in the same programming language. // å¿…é¡»æŠŠæ‰€æœ‰çš„æºä»£ç  æ”¾åœ¨å•ä¸€é¡¹ç›® ä¸­ä¸”ç”¨ç›¸åŒçš„è¯­è¨€
###### In File Explorer. this file is actually called TestHello.csproj, and it is stored in the \Microsoft Press\VCSBS\Chapter 1\TestHello folder in your Documents folder  //æ¯ä¸€ä¸ªproject æ–‡ä»¶ å‚è€ƒ ä¸€ä¸ªæˆ–è€…æ›´å¤šğŸ“ƒ åŒ…å«æºä»£ç ä»¥åŠå…¶ä»–é¡¹ç›®ç‰©ä»¶ï¼Œä¾‹å¦‚å›¾åƒã€‚å¿…é¡»è¦åœ¨å•ä¸€çš„é¡¹ç›®ç”¨åŒä¸€ä¸ªç¼–ç è¯­è¨€ ä¹¦å†™æ‰€æœ‰æºä»£ç ã€‚åœ¨ æ–‡ä»¶æ¢ç´¢ ä¸­ï¼Œæ–‡ä»¶å®é™…ä¸Šæ˜¯å«åš TestHello.csproj ä¿å­˜åœ¨\Microsoft Press\VCSBS\Chapter 1\TestHello æ–‡ä»¶å¤¹ä¸­

#### - **Properties** //å±æ€§
###### This is a folder in the TestHello project. If you expand it(click the arrow next to Properties), you will see that it contains a file called _AssemblyInfo.cs_. //TestHello é¡¹ç›®ä¸­çš„æ–‡ä»¶å¤¹ã€‚å±•å¼€ååŒ…å« _AssemblyInfo.cs_

###### _AssemblyInfo.cs_ is a special file that you can use to add attributes to a program, such as the name of the author, the data the program was written, and so on. //_AssemblyInfo.cs_ æ˜¯ä¸€ä¸ªç‰¹æ®Šæ–‡ä»¶ï¼Œèƒ½å¤Ÿé€šè¿‡å…¶æ·»åŠ å±æ€§åˆ°ç¨‹åºä¸­ï¼Œä¾‹å¦‚ ä½œè€…å§“åï¼Œç¨‹åº âœï¸ æ—¥æœŸç­‰

###### You can specify additional attributes to modify the way in which the program runs. //å£°æ˜ é¢å¤–çš„å±æ€§ è°ƒæ•´é¡¹ç›®è¿è¡Œçš„æ–¹å¼

###### Explaining how to use these attributes is beyond the scope of this book.  //_AssemblyInfo.cs_ æ˜¯ ä¸€ä¸ªç‰¹æ®Šçš„æ–‡ä»¶ ä½¿ç”¨æ·»åŠ  å±æ€§ åˆ°ç¨‹åºä¸­ï¼Œä¾‹å¦‚ ä½œè€…ï¼Œæ—¥æœŸ

#### - **App.config** 
###### you can specify settings that your application uses at run time to modify its behaviourï¼Œsuch as the version of the .NET Framework to run the application //åº”ç”¨ç¨‹åºçš„é…ç½®æ–‡ä»¶, å¹¶ä¸æ€»ä¼šè¢«å±•ç¤ºã€‚

#### - **Program.cs**
###### This is a C# source file, and it is displayed in the Code and Text Editor window when the project is first created. You will write your code for the console application in this file. It also contains some code that Visual Studio provides automatically, which you will examine shortly. //C# æºä»£ç 


|Icon å›¾æ ‡|Meaning å«ä¹‰|
|----|-------|
|![Screen Shot 2022-12-06 at 21 31 52](https://user-images.githubusercontent.com/31954987/205926144-c5c77ec7-9bf4-4db8-87f8-9d490587655f.png)    |Method  æ–¹æ³•(discussed in Chapter3)|
|    |Property(discussed in Chapter15, "implementing properties to access fields")|
|![Screen Shot 2022-12-06 at 21 38 38](https://user-images.githubusercontent.com/31954987/205927973-413165e4-3521-44ee-be86-8b48371053a9.png)    |Class   ç±»(discussed in Chapter7)|
|    |Struct ç»“æ„  (discussed in Chapter9)|
|![Screen Shot 2022-12-06 at 21 50 46](https://user-images.githubusercontent.com/31954987/205930205-8e2a46bb-5407-4280-9029-46fe7722fc6d.png)    |Enum  éå†(discussed in Chapter9)|
|    |Extension method  æ’ä»¶æ–¹æ³•(discussed in Chapter12, "Working with Inheritance")|
|    |Interface   ç•Œé¢(discussed in Chapter13, "Creating interfaces and defining abstract classes")|
|    |Delegate  å§”æ‰˜(discussed in Chapter17, "Introducing generics")|
|âš¡ï¸   |Event  äº‹ä»¶(discussed in Chapter17)|
|![Screen Shot 2022-12-06 at 21 56 11](https://user-images.githubusercontent.com/31954987/205931573-6603ec46-4f76-4ebb-9791-6cc366d6291f.png)      |Namespace  å‘½åç©ºé—´(discussed in the next section of this chapter)|

#### - Using namespaces å‘½åç©ºé—´
###### The example you have seen so far is a very small program. However, small programs can grow into much bigger programs. //ç›®å‰çœ‹åˆ°çš„ä¾‹å­éƒ½æ˜¯å¾ˆå°çš„åº”ç”¨ç¨‹åºï¼Œä½†æ˜¯å°å‹åº”ç”¨ç¨‹åºä¹Ÿä¼šèµ°å‘å¤§å‹åŒ–

###### As a program grows, two issues arise. First, it is harder to understand and maintain big programs than it is to understand and maintain smaller one. Second, more code usually means more classes, with more methods, requiring you to keep track of more names. //æ›´å¤šcode æ„å‘³ç€ æ›´å¤šçš„ classesï¼Œæ›´å¤šçš„ methodsï¼Œéœ€è¦è¿½è¸ªæ›´å¤šçš„ names

###### As the number of names increases, so does likehood of the project build failing bc two or more names clash; you may try to create two classes with the same name. The situation become more complicated when a program references assemblies written by other developers who have also used a variety of names. //éšç€å‘½åæ•°é‡çš„å¢åŠ ï¼Œé¡¹ç›®å› ä¸º2-3ä¸ªå‘½åå†²çªå¯¼è‡´çš„é¡¹ç›®å¤±è´¥çš„æ¦‚ç‡å°±ä¼šå¢åŠ ï¼Œå› ä¸ºä½ å¯èƒ½ç”¨ä¸¤ä¸ªç›¸åŒçš„å‘½åæ–¹å¼åˆ›å»ºäº†ç±»ã€‚è¿™ä¸ªæƒ…å†µä¼šå˜å¾—æ„ˆåŠ å¤æ‚å°¤å…¶æ˜¯å½“ç¨‹åºçš„å‚è€ƒç»„ä»¶ä¹Ÿè¢«å…¶ä»–åˆ«çš„å¼€å‘è€…åŒæ ·ä½¿ç”¨äº†å¤§é‡å‘½åçš„æ—¶å€™

###### In the past, programmers tried to solve the name-clashing problem by prefixing names with some sort of qualifier (or set of qualifiers). //é€šè¿‡ qualifier è§£å†³ å‘½åå†²çª é—®é¢˜

###### this is not a good solution because it's not scalable; names become longer, and you spend less time writing software and more time typing(there is a difference), and reading and rereading incomprehensibly long names. //å¹¶ä¸æ˜¯ä¸€ä¸ªæœ€ä¼˜è§£ï¼Œå› ä¸ºä¸å¯æ‰©å±•ï¼›å‘½åå˜å¾—æ„ˆåŠ å†—é•¿ï¼Œä½ ä¼šä½¿ç”¨æ›´å°‘çš„æ—¶é—´ å†™ç¨‹åº 

###### Namespaces help solve this problem by creating a container for items such as classes. Two classes with the same name will not be confused with each other if they live in different namespaces. You can create a class named _Greeting_ inside the namespace name _TestHello_ by using the _namespace_ keyword like this: //å‘½åç©ºé—´é€šè¿‡åˆ›å»ºä¸€ä¸ª ç»™ ç‰©ä»¶ çš„ å®¹å™¨ï¼Œ
```C#
namespace TestHello //å‘½åç©ºé—´
{
  class Greeting //å®¹å™¨
  {
    ...
  }
}
```
###### you can then refer to the _Greeting_ class as _TestHello.Greeting_ in programs. //. å®é™…æ˜¯referçš„ä½œç”¨

###### If another developer also creates a _Greeting_ class in a different namespace, such as _NewNamespace_, and you install the assembly that contains this class on your computer, your programs will still work as expected bc they are using your _TestHello.Greeting_ class. //å¦‚æœåœ¨ä¸åŒ å‘½åç©ºé—´ å¦ä¸€ä¸ªå¼€å‘è€…ä¹Ÿåˆ›å»ºäº†ä¸€ä¸ª _Greeting_ ç±»ï¼Œä½ å®‰è£…çš„assembly åŒ…å«è¿™ä¸ªç±»åœ¨ç”µè„‘ä¸Šï¼Œä½ çš„ç¨‹åºä»ç„¶ä¼šåƒé¢„æœŸçš„ä¸€æ · è¿ä½œ å› ä¸º ä»–ä»¬ä½¿ç”¨ ä½ çš„ _TestHello.Greeting_ ç±»

###### If you want to refer to the other developer's Greeting class. You must specify it as _NewNamespace.Greeting_. // referå…¶ä»–å¼€å‘è€…çš„ `Greeting`

###### It is good practice to define all your classes in namespaces. Visual Studio environment follows this recommendation by using the name of the project as the top-level namespace. The .NET Framework class library also adheres to this recommendation; every class in .NET Framework class lives within a namespace. For example, the _Console_ class lives within the _System_ namespace. This means that its full name is actually _System.Console_ //åœ¨å‘½åç©ºé—´ä¸­å®šä¹‰æ‰€æœ‰çš„ ç±»ã€‚æ¯ä¸€ä¸ª åœ¨.NET æ¡†æ¶ä¸­çš„ ç±»éƒ½å­˜åœ¨äº å‘½åç©ºé—´ä¸­ã€‚ä¾‹å¦‚ _Console_ ç±» åœ¨ _System_ å‘½åç©ºé—´ä¸­ï¼Œè¿™æ„å‘³ç€ _System.Console_ å®é™…ä¸Šæ˜¯ å‘½åç©ºé—´.ç±»

###### if you had to write the full name of a class every time you used it, the situation would be no better than prefixing qualifiers or even just naming the class with some globally unique name such as _SystemConsole_ Fortunately, you can solve this problem with a _using_ directive in your programs. If you return to the _TestHello_ program in Visual Studio and look at the file Program.cs in the Code and Text Editor window, you will notice the following lines at the top of the file: // å¦‚æœå½“ä½ æ¯æ¬¡ä½¿ç”¨çš„æ—¶å€™éƒ½å¿…é¡»å†™ ç±» çš„å…¨åï¼Œæå‰

```C#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
```

###### These lines are _using_ directives. A _using_ directive brings a namespace into scope. // _using_ æ˜¯æŠŠä¸€ä¸ªå‘½åç©ºé—´ scope çš„åŠ¨ä½œ

###### In subsequent code in the same file, you no longer need to explicitly qualify objects with the namespace to which they belong. // åœ¨ç›¸åŒæ–‡ä»¶ ğŸ“ƒ çš„éšåçš„ä»£ç ä¸­ï¼Œä½ ä¸å†éœ€è¦å» æ˜¾å¼ åœ° ä»¥ç›¸åŒå‘½åç©ºé—´ ä½¿å¯¹è±¡ æœ‰èµ„æ ¼

###### The five namespaces shown contain classes that are used so often that Visual Studio automatically adds these _using_ directives every time you create a new project. You can add more _using_ directives to the top of a source file if you need to reference other namespace. 

###### Try longhand names //

###### - 1. In the Code and Text Editor window displaying the _Program.cs_ file, comment out the first _using_ directive at the top of the file, like this:
``` C#
//using System;
```

###### - 2. On the Build menu, click Build Solution. //
###### The build fails, and the Error List window displays the following error message: // build å¤±è´¥äº†ï¼ŒError List é”™è¯¯åˆ—è¡¨çª—å£ä¼šæ˜¾ç¤ºä»¥ä¸‹é”™è¯¯ä¿¡æ¯
``` C#
The name 'Console' does not exist in the current context.
```

###### - 3. In the Error List window, double-click the error message. The identifier that caused the error is highlighted in the _Program.cs_ source file with a red squiggle. //åœ¨é”™è¯¯åˆ—è¡¨ Error List çª—å£ï¼ŒåŒå‡»é”™è¯¯ä¿¡æ¯ï¼Œ

###### - 4. In the Code and Text Editor windows, edit the _Main_ method to use the fully qualified name _System.Console_.
``` C#
static void Main(string[] args)
{
  system.Console.WriteLine("Hello World!");
}
```
###### - 5. On the Build menu, click Build Solution. 
###### The project should build successfully this time. If it does not, ensure that _Main_ is exactly as it appears in the preceding code, and then try building again. //é¡¹ç›®åº”è¯¥æˆåŠŸå»ºç«‹å¦‚æœä¸æ˜¯ 

###### - 6. Run the application to be sure that it still works by clicking Start Without Debugging on the Debug menu.

###### - 7. When the program runs and displays "Hello World!" in the console window, press Enter to return to Visual Studio

#### Namespace and assemblies //å‘½åç©ºé—´ä¸ç»„ä»¶
###### - A _using_ directive simply brings the items in a namespace into scope and frees you from having to fully qualify the names of classes in your code. Classes are compiled into _assemblies_.

###### An assembly is a file that usually has the .dll file name extension, ä¸¥æ ¼æ„ä¹‰ä¸Šæ¥è¯´ï¼Œä»¥.exe ä¸ºç»“å°¾çš„å¯æ‰§è¡Œç¨‹åº ä¹Ÿæ˜¯ç»„ä»¶ assemblies, an assembly can contain many classes. 

###### The classes that the .NET Framework class lib includes, such as _System.Console_, are provided in assemblies that are installed on your computer together with Visual Studio. 

###### You will find that the .NET Framework class lib contains thousands of classes. 

###### If they were all held in the same assembly, the assembly would be huge and difficult to maintain

###### for the above reason, the .NET Framework class lib is split into a number of assemblies, partitioned by the functional area to which the classes they contain relate. 

###### For example, a "core" assembly (actually called _mscorlib.dll_) contains all the common classes, such as _System.Console_ and other assemblies contain classes for manipulating database, accessing web services, building GUIs, and so on. 

###### If you want to make use of a class in a assembly, you must add a reference to that assembly to your project. 

###### You can then add _using_ directives to your code that bring the items in namespaces in that assembly into scope//æ ¸å¿ƒç»„ä»¶åŒ…å«æ‰€æœ‰å¸¸è§çš„ç±»ï¼Œä¾‹å¦‚

###### You should note that there is not necessarily a 1:1 equivalence between an assembly and a namespace: A single assembly can contain classes defined in many namespaces, and a single namespace can span multiple assemblies. 

###### For example, the classes and items in the _System_ namespace are actually implemented by several assemblies, including _mscorlib.dll_, _System.dll_, and _System.Core.dll_, among others. // ä¸€ä¸ªå•ä¸€çš„assembly èƒ½å¤ŸåŒ…å« å®šä¹‰åœ¨å¾ˆå¤šå‘½åç©ºé—´çš„ ç±»ï¼Œä¸€ä¸ªå•ä¸€çš„å‘½åç©ºé—´ å›Šæ‹¬å¾ˆå¤šassemblies

###### ä½¿ç”¨Visual Studio åˆ›å»ºä¸€ä¸ªåº”ç”¨ç¨‹åºï¼Œè‡ªåŠ¨é€‰æ‹©çš„templateåŒ…æ‹¬ references to the appropriate assemblies. 

###### A console application contains references to assemblies called _Microsoft.CSharp_,_System_, _System.Core_, _System.Xml_, and _System.Xml.Linq_. _mscorlib.dll_ is not included in this list. 

###### The reason for this is that all .NET Framework app must use this assembly bc it contains fundamental runtime functionality. The references folder lists only the optional assemblies; you can add or remove assemblies from this folder as necessary.

### - Create a C# console application.  //åˆ›å»º Csharp æ§åˆ¶ç¨‹åº

### - Explain the purpose of namespace.   //è§£é‡Šå‘½åç©ºé—´çš„ç›®çš„

### - Create a simple graphical C# application. //ç®€æ˜“çš„ å›¾åƒ C# åº”ç”¨ç¨‹åº
